\documentclass[Methods]{subfiles}
\begin{document}
\section{Methods}
\label{sec:Methods}

In order to find the overhead Naxsi has when it is actively used as a \ac{WAF}, it is important to create a baseline reference to compare the results to. First, the performance is measured when there is processing of any application data taken place. This is done by returning HTTP 200 OK message to the client. This way there is a minimal overhead and this makes it possible to isolate Naxsi as much as possible. Second, the performance is measure with a default Wordpress installation. In both cases, the performance is measured first with Naxsi being disabled and later with Naxsi enabled.

Before both scenarios are discussed in more depth, it is important to understand how the basic configuration is setup. A configuration for standard web hosting that is seen quite often, is to separate the web hosting services on a functional basis. First, there is the web server, this the front-end from a client's perspective. Second, there is application layer. The application layer takes care of most of the processing power that is needed to process all the data. Third, there is the data layer, which is often a database server. It is not necessary to separate these layers over different servers. Depending on the requirements, it is possible to host all services on one server. In order to do a performance measurement on one of these services, it is important that not all services run on the same server. Therefore, in this setup, every layer has a dedicated server. In the next section the setup is discussed more in depth.

\subsection{Experimental setup}

Figure \ref{fig:Experimental setup} shows the setup that is used during the experiments. Table \ref{tab:Experimental infrastructure} gives a short description of each server and the service(s) that run(s) on it. Server01 is the front-end server, but it will also act as a software router for basic communication with the servers behind it. Server02 processes all the application data, which for a large part consists of the processing of PHP code. The hardware specification and the software that is used, can be found in appendix \ref{sec:Experimental setup}.

\begin{figure}[h]
\caption{Experimental setup}
\centering
\includegraphics[scale=0.4] {images/infrastructure.png}
\label{fig:Experimental setup}
\end{figure}

\begin{table}[h]
\caption{Experimental infrstructure}
\begin{tabular}{|p{2,5cm}|p{3,5cm}|p{5cm}|}
\hline
\textbf{Hostname} & \textbf{Service} & \textbf{Short description} \\ \hline
server01 & Nginx + Naxsi & Front-end server and router \\ \hline
server02 & Nginx + Fastcgi & Application layer \\ \hline
server03 & MySQL & Data layer \\ \hline
server04 & Benchmark tools & Performance measurement \\ \hline
server05 & Collectd & Performance data collector \\ \hline
\end{tabular}
\label{tab:Experimental infrastructure}
\end{table}

\subsection{Performance measurement tools}
A variety of performance measurement tools (also called benchmarking tools) exist. However not all of them are suited to perform tests in this specific experimental setup while also not influencing the measurement. This section discusses a selection of tools. The sections of those that have in fact been used, specify the way they were set up.

\subsubsection{Apache Benchmark}
\input{methods_tools_apachebenchmark}

\subsubsection{Httperf}
%\input{methods_tools_httperf}

\subsubsection{Autobench}
\input{methods_tools_autobench}

\subsubsection{Collectd}
\input{methods_tools_collectd}

\subsection{Performance measurements}
The performance measurement is done in two phases. The first phase is to measure the baseline performance of the Nginx webserver without Naxsi compiled into it. These measurements are needed to later see the overhead when Naxsi is enabled, as is done in the second phase. In both phases the performance is measured with a Wordpress website on a back-end server and when the Nginx server simply returns an \verb+HTTP 200 OK+ reponse. Details of how the Nginx server is compiled with Naxsi or without can be found in \ref{{sec:server01_configuration}}.

The Wordpress website is introduced in the measurement to see the effects of a more realistic scenario. Based on the \ac{CMS} popularity measurements of March 1st by w3techs \footnote{\url{http://w3techs.com/technologies/overview/content_management/all}}, Wordpress is chosen as the web application. According to their survey, 17,4 \% of all web servers run Wordpress and it holds 54,6 \% of the CMS market share. Wordpress has, by far, the greatests market share and is therefore a popular target for cyber criminals. Naxsi, of course, should block most of these cyber attacks.

\subsubsection{Wordpress}
For the performance measurement when a Wordpress site is active, httperf has proven to be a reliable tool. By measuring the response time of each request and by monitoring the resources on the front-end server, it shows the impact of simply hosting a Wordpress website. This is repeated for both the baseline measurement as for when Naxsi is actively protecting the website.

\subsubsection{HTTP 200 OK}
In order to measure the performance when Nginx replies with \verb+HTTP 200 OK+ messages, httperf is not suitable anymore. The number of requests per second exceed the number of concurrents that are realisticly possible. Instead, the Apache benchmark tools are used. However, the number of requests per second are far greater than that of when a Wordpress website is hosted. Because of the high number of concurrent connections, Apache benchmark shows some discrepencies that need to be taken into consideration. Each individual Apache benchmark command is repeated 5 times, also revered to as a round. A set of rounds is called a step. Of each step, the lowest, highest and average values are graphed to show the discrepancies.

In order to measure the impact Naxsi has on processing the content of the request, we focus on the number of URL parameters. Naxsi has to process each parameter and see if it is allowed. Based on the optimal concurrent connections measured during the baseline measurement, the next thing to be looked at is the number of URL parameters.

\begin{verbatim}
http://200_with_naxsi.test.nl/
http://200_with_naxsi.test.nl/?foo1=bar1
http://200_with_naxsi.test.nl/?foo1=bar1&foo2=bar2
...
\end{verbatim}
\end{document}

